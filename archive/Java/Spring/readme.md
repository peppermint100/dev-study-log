### DI

A 객체가 B 객체의 메소드나 객체를 사용한다고 할 때 이를 A 객체가 B 객체에 의존 한다고 한다.

객체에 의존하는 경우는 A 객체에서 직접 B 객체를 new 생성자로 생성해서 사용할 수 있고

아니면 다른 곳에서 미리 생성된 B 객체를 주입받을 수 도 있다. 

이 때 B객체를 생성해주는(의존 주입을 담당) 다른 곳을 컨테이너라고 하는데,  이 역할을 스프링이

한다. 즉 개발자가 객체를 제어하는 것이 아닌 스프링이 객체를 제어하는 것으로 객체의 컨트롤이 넘어갔다 즉 IOC(Inversion Of Control) 컨테이너라고 할 수 있다.

직접 객체를 생성하는 것을 강한 결합, 주입을 받는 것을 약한 결합, 느슨한 결합이라고 한다.

약한 결합 즉 DI를 이용하면, 객체를 인스턴스화를 할 필요 없게 생성자를 public에서 private으로 변경했을 때 차이가 드러난다. 생성자가 private이 되면 new로 생성할 수 없게 되어 에러가 발생하지만 약한 결합의 경우에는 이러한 변화에 대해서 유연하다.

그리고 실제 상용되는 어플리케이션에서는 클래스들이 엮여서 서로 의존하는 경우가 많기 때문에

계속해서 new 키워드로 생성해내는 것은 비효율적이며 만약 그 클래스가 싱글톤 객체라면 싱글톤

무결성을 해칠 수도 있다.

DI는 대부분 스프링에서 처리를 해주는데 DI를 받는 객체에서 그리고 DI를 사용하는 객체(서비스)에서 각각 어노테이션으로 표기해줌으로서 스프링이 처리를 하도록 할 수 있다.

### 빈

스프링 IOC 컨테이너 안에 들어있는 객체, 컨테이너가 빈 설정 소스(xml)로부터 빈의 정의를 읽고 빈을 구성하여 제공한다. 하지만 요즘에는 구글의 주스가 선보인 방법으로 어노테이션을 이용하여 빈을 이용한다(@service, autowired 등일 이용)

**왜 빈을 사용하는가?**

- 싱글톤으로 객체를 만들어 관리하고 싶을 때(메모리에서 성능최적화, 안정적)
- 의존성 주입을 할 때
- 라이프사이클 인터페이스 사용