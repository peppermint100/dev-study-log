### Type Check

```java
System.out.println(a.getClass());
	System.out.println(a instanceof String);
```

### Byte

byte(1) ⇒ char(2) ⇒ short(2) ⇒ int(4) ⇒ long(8)

int는 4byte이므로 총 32bit의 정수값을 저장 가능하므로 

-2^31 ~ 2^31-1까지의 값을 표현할 수 있다.

### Type 변환

다른 타입을 연산하면 바이트 수가 더 큰 타입으로 자동 변환된다.

### 데이터 타입

정수 타입 : byte, char, short, int, long

실수 타입 : float, double

논리 타입 : boolean

참조 타입 : 배열, 열거, 클래스, 인터페이스

### JVM

1. 자바 파일을 javac를 통해 .class 형태인 자바 바이트 코드로 변경
2. 그 후 운영체제에 맞는(운영체제 종속적인) JVM이 자바 바이트 코드를 해석해서 실행

- 자바의 메모리 사용 영역
1. 메소드 영역 : 클래스, 메소드, 생성자
2. 스레드 : JVM 스택에 변수들이 pop, push 됨
3. 힙: 객체와 배열이 생성됨.

### Class

- 구성요소
1. 필드
2. 생성자
3. 메소드

### 오버로딩

클래스 생성자 및 클래스의 메소드의 매개변수를 한 개, 두 개, 여러 가지로 넣어도 작동하게 여러개의 생성자 및 메소드를 넣어주는 것.

오버로딩(Overloading) : 같은 이름의 메소드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술

오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의 해서 상요한다.

### 접근 제한

public: 모든 클래스에서 접근 가능

protected: 자식 클래스가 아닌 다른 패키지에서는 접근 불가능

default: 다른 패키지에서 접근 불가능

private: 접근 불가능

### 오버라이드 어노테이션

메소드를 오버라이딩 할 때 자식 클래스에서의 메소드이름이 부모 클래스에 존재하지 않는다면 즉 개발자가 메소드의 이름을 헷갈려서 자식클래스에서 틀려버린다면 에러를 발생시킨다.

### 상속

```java
public class Bus extends Car{
    public Bus(String name, String company) {
        super(name, company);
    }
}
```

상속은 super로 가져오고 만약 부모 클래스에서 상속 시키고 싶지 않은 메소드나 객체는 final로 선언해주면 된다. 클래스 자체를 final로 선언하면 아예 상속 자체가 안된다.

### 추상 클래스

추상 클래스는 공통된 성질을 나타내주고 new로 생성되어 질 수 없다. 즉 extends 뒤에만 나올수 있다.

추상 클래스의 사용 이유 

1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일
2. 실체 클래스 작성시 시간 절약

### 인터페이스

개발 코드와 객체 사이에서 통신하는 접점 역할을 한다. 개발 코드가 직접 메소드를 호출하면 간단하지만 인터페이스를 사용하는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경시키기 위해서 사용한다. 개발 코드 측면에서 코드 변경 없이 실행 내용과 리턴값을 다양화 할  수 있다.

### 예외처리

에러에는 일반 예외, 실행 예외가 있다. 일반 예외는 컴파일러가 동작 전에 잡아주지만 실행 예외는 개발자가 예상하고 예외를 처리해야만 한다. 일반 예외는 Exception을 상속받고 실행 예외는 RuntimeException을 상속받는다.

가장 자주 볼 수 있는 실행 예외는 아래와 같다.

- NullPointerException
- ArrayIndexOutOfBoundsException
- NumberFormatException
- ClassCastException(부모클래스와 자식클래스의 타입 변환시 발생)

다중 캐치의 경우 하위 예외 클래스를 먼저 처리해주고 가장 나중에 Exception 즉 최상위 예외클래스를 처리해주어야 한다.

### 스레드

```java
Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello world");
            }
        });
        thread.start();
```

자바는 멀티 스레드를 지원하고 메인 메소드에서 메인 스레드가 실행이 되고 다른 클래스를 이용할 수록 스레드가 하나씩 추가되어 실행된다.

위와 같이 Thread와 Runnable 객체를 이용하여 스레드를 직접 만들고  start 메소드를 통해 실행시킬수 있다.

### 람다식

→ 메소드를 매개변수로 전달해 주기 위하여 만들어짐, runnable과 같이 하나의 메소드만 가진 인터페이스에만 적용가능

- JVM이 스레드 생성자가 어떤 인터페이스를 구현할지 추론하게 됨.

### 컬렉션 프레임워크

세 개의 추상 클래스로 이루어져 있으며 각각 구현 클래스가 있다.

- List

ArrayList는 뒤에 순차적으로 값을 추가하는 배열에 용이하고 LinkedList는 값을 중간에 추가, 삭제할 때 유용하다. 자신의 앞 뒤 값만 저장하기 떄문이고 ArrayList는 중간 인덱스를 삭제시 뒤 인덱스들이 전부 한 칸 씩 당겨오므로 비효율적이다. Vertor는 동기화된 메소드로 구성되어 있어 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.

- Set

Set은 저장순서가 유지되지 않고 중복값을 허용하지 않는다. 그래서 null 값도 하나만이 들어갈 수 있다. Set은 값들을 인덱스로 관리하지 않기 때문에 인덱스를 매개값으로 메소드가 없다.

- Map

Key, Value 쌍으로 이루어져 있으며 키와 값은 모두 객체이고 키는 중복저장 될 수 없게 되어 있다.